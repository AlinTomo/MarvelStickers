<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous"/>
    <link rel="stylesheet" href="css/navbar.css">
    <link rel="stylesheet" href="css/trade.css">
    <title>Trades</title>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js" integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+" crossorigin="anonymous"></script>
    <script src="globals.js"></script>
    <script src="nav.js"></script>
    <div class="container">
        <h1 id="firstTitle" class="text-center mt-3">Cards to propose for trades</h1>
        <p id="noDuplicates" class="d-none text-center mt-3">no possible trades</p>
        <form action="" onsubmit="event.preventDefault();createTrade();">
            <div id="form" class="card scrollable">
                <div  class="card-body mt-0 pt-0">
                    <div id="cardsRow" class="row">
                        <div id="copy" class="col-xl-2 col-lg-2 col-md-3 col-sm-3 mt-2">
                            <div class="card d-none">
                                <img class="card-img-top" src="">
                                <div class="card-body">
                                    <h5 class="card-title text-center"></h5>
                                </div>
                                <div class="card-footer d-flex justify-content-center">
                                    <button class="btn btn-dark" type="button">open</button>
                                </div>
                                <input class="range-dark mx-xl-5 mx-lg-3 mx-md-3 my-md-3" type="range" oninput="showValue(this)" min="0" max="" value="" step="1">                    </div>
                        </div>
                    </div>  
                </div>
            </div>
            <div  class="float-end">
                <button id="submit" class="btn btn-dark my-2" type="submit">Send</button>
            </div>
        </form>
        <h1 id="secondTitle" class="text-center mt-20">Possible trades</h1>
        <p id="noSuggestedTrades" class="d-none text-center mt-3">no suggested trades</p>
        <div id="suggestTrade" class="card scrollable">
            <div class="card-body mt-0 pt-0 tradesRow d-none my-2">
                <div class="row mb-2">
                    <div class="col-6 card-body">
                        <h3 id="" class="card-title nameSurname">Possible trade from:</h3>
                    </div>    
                    <select class="col-6 form-select proposal decision" onchange="chooseProposal(this)">
                        <option selected disabled hidden value="1">Choose proposal</option>
                    </select>
                </div> 
                <div class="row justify-content-space-between row-sm">
                    <div class="col-md-5 col-sm-12">
                        <div class="row others justify-content-end">
    
                            <!--le card vegono generate -->
                        </div>
                    </div>
                    <div class="col-1 d-flex justify-content-center">
                        <button class="btn btn-dark my-auto transfer" onclick="makeProposal(this)" type="submit">
                            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-arrow-left-right" viewBox="0 0 16 16"  stroke-width="0.8" stroke="currentColor">
                                <path fill-rule="evenodd" d="M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5m14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5"/>
                            </svg>              
                        </button>
                    </div>
                    <div class="col-md-5 col-sm-12">
                        <div class="row my justify-content-start">
    
                            <!--le card vegono generate -->
                        </div>
                    </div>
                </div>
            </div>
        </div> 

        <h1 id="thirdTitle" class="text-center mt-20">Proposals pending</h1>
        <p id="noPendingTrades" class="d-none text-center mt-3">no pending trades</p>
        <div id="pendingTrade" class="card scrollable mb-5">
            <div class="card-body mt-0 pt-0 tradesRow d-none my-2">
                <div class="row mb-2">
                    <div class="col-6 card-body">
                        <h3 class="card-title nameSurnamePending">Trade proposed by:</h3>
                    </div>    
                    <select class="col-6 form-select decision made" onchange="makeADecision(this)">
                        <option selected disabled hidden value="">Make your choice</option>
                        <option class="accept" value="yes">Accept</option>
                        <option class="decline" value="no">Reject</option>
                    </select>
                </div> 
                <div class="row justify-content-space-between row-sm">
                    <div class="col-md-5 col-sm-12">
                        <div class="row others justify-content-end">
    
                            <!--le card vegono generate -->
                        </div>
                    </div>
                    <div class="col-1 d-flex justify-content-center">
                        <button class="btn btn-dark my-auto transfer" type="submit">
                            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor" class="bi bi-arrow-left-right" viewBox="0 0 16 16"  stroke-width="0.8" stroke="currentColor">
                                <path fill-rule="evenodd" d="M1 11.5a.5.5 0 0 0 .5.5h11.793l-3.147 3.146a.5.5 0 0 0 .708.708l4-4a.5.5 0 0 0 0-.708l-4-4a.5.5 0 0 0-.708.708L13.293 11H1.5a.5.5 0 0 0-.5.5m14-7a.5.5 0 0 1-.5.5H2.707l3.147 3.146a.5.5 0 1 1-.708.708l-4-4a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 4H14.5a.5.5 0 0 1 .5.5"/>
                            </svg>              
                        </button>
                    </div>
                    <div class="col-md-5 col-sm-12">
                        <div class="row my justify-content-start">
    
                            <!--le card vegono generate -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
<script>
    var idUser = localStorage.getItem("idUser");
    main(idUser);

    async function main(idUser) {
        validateLog();
        document.getElementsByClassName('nav-link')[1].classList.add('active');
        document.getElementById('cartLink').classList.add('d-none');
        localStorage.setItem('Pag', 3); //viene usato in loadLang quindi va settato prima
        loadLang();
        await trades(idUser); //trova e fa vedere a schermo le carte che non sono state proposte in nei vari scambi
        await manageTrade(idUser); //gestisce e fa vedere a schermo tutta la parte degli scambi che hanno stato, unsolicited, pending e standBy;
        await managePendings(idUser);
    }

    /*funzione che gestice gli scambi gia creati dagli utenti facendoli vedere ad altri user e dando la possbilità ai vari user 
    di creare uno trade unico in cui ci sono le carte che si voglio scambiare 
    da entrambe le parti degli utenti*/
    async function manageTrade(idUser) { 
        deletePreviusRows("suggestTrade");
        let userTrades = await findTrade(idUser); //trovo le proposte di scambio dell'utente
        numberUserTrades = userTrades.length; //numero di scambi dell'utente
        if(numberUserTrades > 0){ //se ce almeno una proposta proposta di scambio dallo user fai vedere i trade
            document.getElementById("suggestTrade").classList.remove("d-none");
            document.getElementById("noSuggestedTrades").classList.add("d-none");
            let otherTrades = await tradesFromOthers(idUser); //raccolta di tutte le proposte di scambio degli altri utenti
            userCards = await getUserCards(idUser); //carte dell'utente
            // console.log(userCards)
            suggestTrade = suitableTr(userCards.cards,otherTrades); //scambi di carte dove le carte da scambiare non esistono nel mazzo dell'utente
            if(suggestTrade.length > 0){ //nel caso in cui ho più set di carte da scambia da proporre nei vari trade
                // console.log("scambi possibili per l'utente",suggestTrade);
                // console.log("prima proposta utente",userTrades[0].initiator.cards);
                selectProposal(numberUserTrades,userTrades); 
                for (let i = 0; i < suggestTrade.length; i++) {
                    nameSurname = await getNameSurnameUser(suggestTrade[i].initiator.idUser);
                    await showPossibleTrades(suggestTrade[i].initiator.cards,"suggestTrade","others",suggestTrade[i]._id);
                    document.getElementsByClassName("nameSurname")[i + 1].textContent += " " + nameSurname[0] +"."+ nameSurname[1];
                    await addMyTradeToPossibleTrade(userTrades[0].initiator.cards,"suggestTrade","my",i);
                }
            }
            else{
                document.getElementById("suggestTrade").classList.add("d-none");
                document.getElementById("noSuggestedTrades").classList.remove("d-none");
            }  
        }
        else{
            document.getElementById("suggestTrade").classList.add("d-none");
            document.getElementById("noSuggestedTrades").classList.remove("d-none");
        }
    }

    function deletePreviusRows(id){ //serve quando si richiama una seconda volta manageTrade per eliminare le proposte precedenti
        let father = document.getElementById(id);
        let first = father.getElementsByClassName("tradesRow")[0];
        let option;
        if(id == "suggestTrade"){    
            option = first.getElementsByClassName("decision")[0].options[0];
            while(option.nextElementSibling != null){
                option.nextElementSibling.remove();
            }
        }
        while(first.nextElementSibling != null){
            first.nextElementSibling.remove();
        }
    }

    async function trades(idUser) { //fa vedere nel form quali carte si possono ancora proporre rispetto a quelle doppie e quelle gia proposte
        //zona carte gia proposte per lo scambio nei loro vari stati---------------------------------------------
        deleteCards();
        let previousTrades = await findTrade(idUser); //cerco se ci sono scambi precedenti in cui ce solo la proposta senza che un altro utente sia coinvolto
        let allPendings = await findPending(idUser,"initiator"); //cerco tutti gli scambi in cui lo user è un initiator
        let allStandBy = await findStandBy(idUser); //cerco tutti gli scambi in cui lo user è un receiver
        // console.log("non completo",previousTrades);
        // console.log("pendings",allPendings);
        // console.log("stadBy",allStandBy);
        previousTrades = allPreviusPendingsStandBy(previousTrades,allPendings,allStandBy);
        console.log("completo",previousTrades);
        let previousCards = []; //creo un array con le carte degli scambi precedenti
        let prevQuantityCards = 0; //creo una variabile per contare le carte degli scambi precedenti
        previousTrades.forEach(trade => {
            //console.log(trade.initiator.cards);
            trade.initiator.cards.forEach(card => {
                // console.log(card);
                previousCards.push(card);
                prevQuantityCards += card.count;
            });
        });
        // console.log("carte totali precedenti",prevQuantityCards);
        //zona carte totali potenzialmente da scambiare------------------------------------
        let heroes = await getUserHeroes();    
        let duplicates = findDuplicates(heroes);
        // console.log("carte doppie",duplicates);
        let quantityCards = 0; //carte totali da scambiare
        duplicates.forEach(duplicate => {
            quantityCards += duplicate.count;
        });
        // console.log("carte totali attuali",quantityCards);
        //zona controllo se ci sono carte da poter proporre per scambiarle---------------------------------------
        let exchangeable = false //variabile che stabilisce se ci sono ancora carte disponibili per 
        document.getElementById("submit").classList.remove("d-none");
        if(duplicates.length > 0){//controllo se ho carte doppie
            if(quantityCards == prevQuantityCards){//ho proposto tutte le carte doppie negli scambi precedenti
                exchangeable = false;
            }
            else 
                if(prevQuantityCards < quantityCards){//ho ancora qualche carta da scambiare
                    exchangeable = true;
                    // console.log(previousCards);
                    if(previousCards.length > 0)
                        duplicates = cardsNotProposed(previousCards,duplicates); //tolgo le carte già proposte
                    // console.log("actualizate",duplicates);
                }
                else{
                    exchangeable = false;
                }
        }  
        
        if(exchangeable){
            genUserCards(duplicates,0);
        }
        else{
            disableTradingForm();
        }
        return previousTrades;
    }

    function deleteCards(){//cancella le card precedenti quando viene ricaricata la funzione trade
        let clone = document.getElementById("copy");
        while(clone.previousElementSibling != null){
            clone.previousElementSibling.remove();
        }
    }

    /*gestisce tutti gli scambi attivi in cui lo user è coinvolto lo user li puo accettare o rifiutare, 
        se lo user(receiver) accetta gli scambi in pending e in standBy vengo cancellati e le carte vengono scambiate tra gli utenti
        se lo user(receiver) rifiuta lo scambio il trade in stato di standBy del receiver diventa in stato di unsolicited mentre il trade in stato di pending viene cancellata la parte del receiver e lo stato viene cambiato in unsolicited
    */
    async function managePendings(idUser) { //vedo quali richieste di trade mi sono arrivate
        deletePreviusRows("pendingTrade");
        let pendingTrades = await findPending(idUser,"receiver"); //cerco tutti gli trade in cui lo user è un receiver
        if(pendingTrades.length > 0){ //caso in cui ho dei trade da accettare/rifiutare
            // console.log(pendingTrades);
            document.getElementById("noPendingTrades").classList.add("d-none");
            // document.getElementsByClassName("pendingsRow")[0]
            for (let i = 0; i < pendingTrades.length; i++) {
                    nameSurname = await getNameSurnameUser(pendingTrades[i].initiator.idUser);
                    await showPossibleTrades(pendingTrades[i].initiator.cards,"pendingTrade","others",pendingTrades[i]._id);
                    document.getElementsByClassName("nameSurnamePending")[i + 1].textContent += " " + nameSurname[0] +"."+ nameSurname[1];
                    await addMyTradeToPossibleTrade(pendingTrades[i].receiver.cards,"pendingTrade","my",i);
                }
        }
        else{ //caso in cui non ho dei trade da accedare rifiutare
            document.getElementById("noPendingTrades").classList.remove("d-none");
            document.getElementById("pendingTrade").classList.add("d-none");
        }
    }

    function allPreviusPendingsStandBy(previus,pending,standBy){ //restiutisce tutti gli scambi precedenti in cui lo user è coinvolto
        let all = [];
        if(previus.length > 0){
            previus.forEach(trade => {
                all.push(trade);
            });
        }
        
        if(pending.length > 0){
            pending.forEach(trade => {
                all.push(trade);
            });
        }
        
        if(standBy.length > 0){
            standBy.forEach(trade => {
                all.push(trade);
            });
        }
        return all;
    }

    function cardsNotProposed(previousCards,actualCards){//dalle carte doppie toglie quelle che risultano gia proposte 
        previousCards.forEach(card => {
            for (let i = 0; i < actualCards.length; i++){
                if(card.id == actualCards[i].id){
                    if(card.count == actualCards[i].count){
                        actualCards.splice(i,1);
                    }
                    else{
                        actualCards[i].count -= card.count;
                    }
                }
            }
        });
        // console.log(actualCards);
        return actualCards;
    }

    function disableTradingForm(){ //disabilita il form di scambio se non ci sono più carte da poter proporre negli scambi
        paragraph = document.getElementById("noDuplicates");
        paragraph.classList.remove("d-none");
        document.getElementById("form").classList.add("d-none");
        document.getElementById("submit").classList.add("d-none");
    }

    async function getUserHeroes(){//ottengo gli eroi dello user dal db
        let flag = false;
        return await fetch("http://localhost:3000/users/"+idUser+"/heroes?api_key="+api_key,get)
        .then(respose =>{
            if(respose.status == 200){
                flag = true;
            }
            return respose.json();
        })
        .then(response =>{
            if(flag){   
                return response.cards;
            }
            return null;
        })
    }
    
    function findDuplicates(array) { //trova le figurine doppie che l'utente ha in totale
        let duplicates = [];
        for (let i = 0; i < array.length; i++) { //per ogni elemento dell'array
            if (!duplicates.some(duplicate => duplicate.id == array[i])) { //se non è già stato inserito
                let count = (array.filter(item => item === array[i]).length) - 1; //conto quante volte lo trovo nell'array e poi metto solo le ripetizioni
                if (count > 0) {//se si ripete più di una volta lo inserisco
                    duplicates.push({ id: array[i], count: count });
                }
            }
        }   
        // console.log("roba doppia",duplicates);
        return duplicates;
    }

    async function genUserCards(cards,offset){ //fa vedere a schermo le carte dell'utente (leggera variante rispetto a quella in index.html)
        let heroes = [];
        finalOffset = offset + 21;
        // console.log("eroi totali",cards.length);
        // console.log("offset di partenza",offset);
        if(finalOffset > cards.length)
            finalOffset = offset + (cards.length - offset);
        // console.log("offset finale",finalOffset);
        for (let i = offset; i < finalOffset; i++) {  
            response = await getFromMarvel("public/characters/" + cards[i].id, "",false);
            heroes.push(response.data.results[0]);       
        }
        copy = document.getElementById('copy');
        while(copy.previousElementSibling != null){
            copy.previousElementSibling.remove();
        }
        for (let i = 0; i < heroes.length; i++) { 
            temp = copy.cloneNode(true);
            temp.getElementsByClassName('card-img-top')[0].src = heroes[i].thumbnail.path+"."+heroes[i].thumbnail.extension;
            temp.getElementsByClassName('card-title')[0].textContent = heroes[i].name;
            temp.getElementsByClassName('card')[0].classList.remove('d-none');
            temp.getElementsByClassName("btn")[0].id = cards[i].id;
            temp.getElementsByClassName("btn")[0].textContent = "x" + cards[i].count;
            let range = temp.getElementsByClassName("range-dark")[0];
            range.max = cards[i].count;
            range.value = cards[i].count;
            temp.id = i;
            copy.before(temp);
        }    
    }
    
    function showValue(range){//fa vedere il valore della range selezionato dall'utente
        range.previousElementSibling.getElementsByClassName("btn")[0].textContent = "x" + range.value;
    }

    async function createTrade(){ //carico nel db la proposta di scambio da parte dell'iniziatore
        console.log("ciao")
        let row = document.getElementById("cardsRow");
        let array = Array.from(row.getElementsByClassName("btn"));
        let objArray = [];
        for (let i = 0; i < array.length - 1; i++) {
            let id = parseInt(array[i].id);
            let substr = array[i].textContent;
            substr = parseInt(substr.substring(1,substr.length));
            if(substr == 0)
                continue;
            obj = {id: id, count: substr};
            objArray.push(obj);
        }
        // console.log(objArray);
        let trade = {
            initiator: {
                idUser: idUser,
                cards: objArray
            },
            status: "unsolicited",
            receiver: null
        };
        let flag = false;
        let res = await fetch("http://localhost:3000/trades?api_key="+api_key, setPostOption(trade))
        .then(response => {
            if(response.status == 200){
                flag = true;
                console.log("scambio creato");
            }
            return response.json();
        })
        .then(response => {
            console.log(response);
            return flag;
        })
        if(res){
            console.log(res);
            await trades(idUser);
            await manageTrade(idUser);
            await managePendings(idUser);
        }
    }

    async function findTrade(id){//cerco nel db se ci sono scambi iniziati(proposti) dall'utente
        let flag = false;
        return await fetch("http://localhost:3000/trades/"+id+"?api_key="+api_key,get)
        .then(response => {
            if(response.status == 200){
                flag = true;
            }
            return response.json();
        })
        .then(response => {
            if(flag){
                return response;
            }
            else{
                return false;
            }
        })
    }

    async function findStandBy(id) { //trova tutti i trade in cui l'utente è impostato come receiver
        let flag = false;
        return await fetch("http://localhost:3000/trades/allStandBy/"+id+"?api_key="+api_key,get)
        .then(response => {
            if(response.status == 200){
                flag = true;
            }
            return response.json();
        })
        .then(response => {
            if(flag){
                return response;
            }
            else{
                return false;
            }
        })
    }

    async function findPending(id,sideOfUser) { //trova tutti i trade in cui l'utente è impostato come initiator
        let flag = false;
        return await fetch("http://localhost:3000/trades/allPending/"+id+"/"+sideOfUser+"?api_key="+api_key,get)
        .then(response => {
            if(response.status == 200){
                flag = true;
            }
            return response.json();
        })
        .then(response => {
            if(flag){
                return response;
            }
            else{
                return false;
            }
        })
    }

    async function tradesFromOthers(id){//cerco nel db dei possibli scambi proposti da altri utenti
        try {
            let response = await fetch("http://localhost:3000/trades/allUnsolicited/" + id + "?api_key=" + api_key, get);
            if (response.status === 200) {
                let data = await response.json();
                return data; // Return the actual result of the promise
            } else {
                return false; // Return false if the response status is not 200
            }
        } catch (error) {
            console.error('Error fetching trades:', error);
            return false; // Return false if there was an error during the fetch
        }
    }

    async function getUserCards(id) { //ottiene tutte le carte dello user
        try {
            let response = await fetch("http://localhost:3000/users/" + id + "/heroes?api_key=" + api_key, get);
            if (response.status === 200) {
                let data = await response.json();
                return data; // Return the actual result of the promise
            } else {
                return false; // Return false if the response status is not 200
            }
        } catch (error) {
            console.error('Error fetching trades:', error);
            return false; // Return false if there was an error during the fetch
        }
        console.log("response db",response);
        return response;
    }

    function suitableTr(userCards,otherTrades){//stabilisco quali sono i potenziali scambi idoneei per lo user
        let suitableTrades = [];
        // console.log("scambi degli altri", otherTrades);
        // console.log("carte dello user",userCards);
        let acceptable = true;
        for (let i = 0; i < otherTrades.length; i++,acceptable = true) {
            let trade = otherTrades[i]; 
            for (let i = 0; i < trade.initiator.cards.length; i++) {
                let guestCard = trade.initiator.cards[i];
                // console.log("guestCard",guestCard.id);
                if (userCards.includes(guestCard.id)) {
                    // console.log("id:",trade._id,"\n trade non accettato",trade.initiator.cards)
                    acceptable = false;
                    break;
                }
            }
            if(acceptable)
                suitableTrades.push(trade);
        };
        // console.log("trade accettati",suitableTrades);
        return suitableTrades;
    }

    //la variabile rowClassName deve assumere le parole others/ my pechè così posso riempiere la parte giusta dello scambio
    /*la variabile tradeManageZone serve per capire se devo gestire gli scambi in pending o in unsolicited 
    tradeManagedZone deve valere o suggestTrade oppure pendingTrades */
    async function showPossibleTrades(cards,tradeManageZone,rowClassName,_id){//fa vedere agli utenti i possibili scambi che possono fare
        let trade = document.getElementById(tradeManageZone); //ottengo il div che contiene tutti i trade proposti
        let trRow = trade.getElementsByClassName("tradesRow")[0]; //ottengo il div che mi descrive tutte le infromazioni riguardanti gli scambi
        let trRowCopy = trRow.cloneNode(true);
        trRowCopy.classList.remove("d-none");
        await addCardsInRows(cards,rowClassName,trRowCopy);
        trade.appendChild(trRowCopy); //aggiungo alla sezioen dei possbili scambi i singolo scambi con le relative info
        // console.log(trRowCopy);
        if(tradeManageZone == "suggestTrade"){
            let last = document.getElementsByClassName("nameSurname").length;
            // console.log("var da attaccare a nameSuranme",last)
            // console.log("_id: ",_id);
            document.getElementsByClassName("nameSurname")[last - 1].id = _id;
        }
        else{
            let last = document.getElementsByClassName("nameSurnamePending").length;
            // console.log("var da attaccare a nameSuranme",last)
            // console.log("_id: ",_id);
            document.getElementsByClassName("nameSurnamePending")[last - 1].id = _id;
        }
    }

    async function addMyTradeToPossibleTrade(cards,tradeManagedZone,rowClassName,index) { //aggiunge lo info dello scambio proposto dall'utente all'intero trade
        let trade = document.getElementById(tradeManagedZone);
        let trRows = Array.from(trade.getElementsByClassName("tradesRow"));
        let internalRow = (trRows[index + 1]).getElementsByClassName("row-sm")[0];//mi serve per assegnare id per poi aggioranre le proposte utente con una select
        // console.log(internalRow);
        // console.log("id",internalRow.id);
        if(tradeManagedZone == "suggestTrade"){
            if(!isNaN(internalRow.id)){ //assegno un id che serve per quando devo trovare la row giusta di cui devo fare il cambio di carte proposte dallo user
                internalRow.id = index + 1;
                // console.log("after",internalRow.id);
            }
        }
        await addCardsInRows(cards,rowClassName,trRows[index + 1],index);
    }
    
    async function addCardsInRows(cards,rowClassName,trRow){ 
        /*aggiunge ad una row a scelta le info riguradanti delle cards a scelta 
        (per rowClassname sceli other o my che sono i valori che indicano i trade proposti da me o dagli altri)
        trRow è la card esterna che contine tutte le info riguradanti il trade 
        */    

        row = trRow.getElementsByClassName(rowClassName)[0]; //ottengo il div che gestisce solo le carte che vengono scambiate
        while (row.firstChild) {//rimuovo i figli nel caso in cui la row ne abbia
            row.removeChild(row.firstChild);
        }
        
        // console.log("cardRow", row);
        for (let i = 0; i < cards.length; i++) {
            let clone = generateCard();
            // console.log(sticker.id);
            let response = await getFromMarvel("public/characters/" + cards[i].id, "", false);
            // console.log(response)
            addCardData(clone,response,cards[i].count);
            row.appendChild(clone);
        }
    }

    function addCardData(card,response,cardCount){//popola di dati le carte in trade.html
        //card è la carta in html, response solo le info mentre cardCount riguarda la quantità di carte da voler rappresentare
        card.getElementsByClassName("card-img-top")[0].src = response.data.results[0].thumbnail.path + "." + response.data.results[0].thumbnail.extension;
        card.getElementsByClassName("card-title")[0].textContent = response.data.results[0].name;
        card.getElementsByClassName("card")[0].classList.remove("d-none");
        card.getElementsByClassName("btn")[0].textContent = cardCount;
    }

    function generateCard() { //genera la card che mi serve da aggiungere
    // Creazione del div principale
        const divCol = document.createElement('div');
        divCol.classList.add('col-xl-3', 'col-lg-4', 'col-md-4', 'col-sm-3', 'my-2', 'all');

        // Creazione della card
        const card = document.createElement('div');
        card.classList.add('card');

        // Creazione dell'immagine
        const img = document.createElement('img');
        img.classList.add('card-img-top');
        img.setAttribute('src', '');

        // Creazione del corpo della card
        const cardBody = document.createElement('div');
        cardBody.classList.add('card-body');

        const h5 = document.createElement('h5');
        h5.classList.add('card-title', 'text-center', 'mt-2');
        h5.textContent = '';  // Titolo vuoto, puoi riempirlo come vuoi

        // Aggiunta del titolo alla body della card
        cardBody.appendChild(h5);

        // Creazione del footer della card
        const cardFooter = document.createElement('div');
        cardFooter.classList.add('card-footer', 'd-flex', 'justify-content-center');

        // Creazione del bottone
        const button = document.createElement('button');
        button.classList.add('btn', 'btn-dark');
        button.setAttribute('type', 'button');
        button.textContent = 'open';

        // Aggiunta del bottone al footer
        cardFooter.appendChild(button);

        // Assemblaggio della card
        card.appendChild(img);
        card.appendChild(cardBody);
        card.appendChild(cardFooter);

        // Aggiunta della card al div principale
        divCol.appendChild(card);

        // Restituisce il div con la card completa
        return divCol;
    }

    function selectProposal(numberUserTrades,userTrades){//crea la select da stampare a video con il numero di proposal da fare
        let proposals = Array.from(document.getElementsByClassName("proposal"));
        let obj = {
                        cards: userTrades[0].initiator.cards,
                        position: 0 //posizione dell'array di trade dell'utente pk quello gia preselezionato è il primo
                    }
        proposals[0].options[0].value = JSON.stringify(obj);
        if(numberUserTrades <= 1){  //se ce una sola proposta o meno non si fa vedere il menu
            proposals.forEach(proposal => {
                proposal.classList.add("d-none");
            });
        }
        else{
            for (let j = 0; j < numberUserTrades; j++) {
                console.log(userTrades[j]);
                let option = document.createElement("option");
                let obj = {
                    cards: userTrades[j].initiator.cards,
                    position: j
                }
                option.value = JSON.stringify(obj); //aggiungo i dati del trade dell'option per non chiamarli dal db
                option.textContent = (j + 1);
                proposals[0].appendChild(option);
                proposals[0].classList.remove("d-none");
            }
        }
    }

    async function chooseProposal(select){ //le proposte di carte che hai scelto nella select
        cards = (JSON.parse(select.value)).cards;
        // console.log(cards);
        trRow = (select.parentElement).nextElementSibling;
        // console.log("trRow",trRow);
        // console.log("QUELLO CHE VOGLIO",trRow.id);
        await addMyTradeToPossibleTrade(cards,"suggestTrade","my",trRow.id - 1);
    }

    async function makeProposal(arrowButton){ //fai una query al db dove imposti la proposta di trade
        console.log(arrowButton.parentElement.parentElement);
        let select = arrowButton.parentElement.parentElement.previousElementSibling;
        let id = select.getElementsByClassName("nameSurname")[0].id;
        console.log(select.getElementsByClassName("proposal")[0].options[0].value);
        let obj = JSON.parse(select.getElementsByClassName("proposal")[0].options[0].value);
        let userChoose = obj.position; 
        // console.log("id",id);
        //  console.log("userChoose",userChoose);
        let tradeReciverData =  await getSpecificTrade(id); //dati del trade ricevente (i dati dell'initiator antrando nel ricevente del trade dell'utente)
        let tradeSenderData = await getSepecificUserTrade(userChoose); //dati da aggiungere add tradeData per completare i dati della proposta pending
        console.log(tradeSenderData);
        let tempObj = { //creo un oggetto temporaneo per poterlo aggiungere al tradeSenderData
            idUser: tradeReciverData.initiator.idUser,
            cards: tradeReciverData.initiator.cards
        }
        tradeSenderData = {
            _id: tradeSenderData._id,
            initiator: tradeSenderData.initiator,
            receiver: tempObj,
            status: "pending",
            standByTrade: tradeReciverData._id 
            //id del trade del ricevente che verrà messo in stand by, id che servirà per trovare la proposta per poter aggiornare lo stato oppure cancellarla
        }
        console.log("proposta completa",tradeSenderData);
        await updateStatusPending(tradeSenderData._id,tradeSenderData);
        let lastResponse = await setStandByStatus(tradeReciverData._id);
        console.log(lastResponse);
        if(lastResponse.response == "ok"){
            await trades(idUser); //trova e fa vedere a schermo le carte che non sono state proposte in nei vari scambi
            await manageTrade(idUser); //gestisce e fa vedere a schermo tutta la parte degli scambi che hanno stato, unsolicited, pending e standBy;
            await managePendings(idUser); 
        }
    }

    async function getSpecificTrade(idTrade){ //ottieni un trade fornendo uno specifico id 
        let flag = false;
        if(idTrade){ 
            return await fetch("http://localhost:3000/trade/"+idTrade+"?api_key="+api_key,get)
            .then( response =>{
                if(response.status = 200){
                    flag = true;
                }
                return response.json()
            })
            .then (response =>{
                if(flag){
                    return response;
                }
                return false;
            })
        }
    }

    async function getSepecificUserTrade(index) {//ottieni uno specifico trade fornendo l'index
        let trades = await findTrade(idUser);
        return trades[index]; //l'array parte da zero 
    }

    async function setStandByStatus(idTrade) { //quando si fa una proposta di scambio la proposta del reciver viene messa in standBy
        obj = {
            status : "standBy"
        };
        return await fetch("http://localhost:3000/trades/"+idTrade+"/standBy?api_key="+api_key,setPostOption(obj))
        .then(response => {
            return response.json();
        })
        .then(response =>{
            // console.log(response);
            return response;
        })
    }

    async function updateStatusPending(idTrade,obj) {//quando si fa una proposta di scambio la proposta dell'initiator viene messa in pending
        await fetch("http://localhost:3000/trades/"+idTrade+"/pending?api_key="+api_key,setPostOption(obj))
        .then(response => {
            return response.json();
        })
        .then(response =>{
            console.log(response);
        })
    }

    async function makeADecision(select) { //funzione che gestisce la decisione dell'utente se accettare o rifiutare lo scambio
        // console.log(select.previousElementSibling);
        let idTrade = (select.previousElementSibling).getElementsByClassName("nameSurnamePending")[0].id;
        // console.log("id",idTrade);
        let tradeComplete = await getSpecificTrade(idTrade);
        // console.log("trade",tradeComplete);
        // console.log("idStandBy",tradeComplete.standByTrade);
        let standBy = await getSpecificTrade(tradeComplete.standByTrade);
        // console.log("standBy",standBy);
        if(select.value == "yes"){
            // console.log("accetto");
            let res = await makeTheEffectiveTrade(tradeComplete.initiator.idUser,tradeComplete.receiver.cards,tradeComplete.initiator.cards);
            // console.log("resInitiator",res);
            res = await makeTheEffectiveTrade(tradeComplete.receiver.idUser,tradeComplete.initiator.cards,tradeComplete.receiver.cards);
            // console.log("resRecevier",res);
            res = await deleteTrades(idTrade,tradeComplete.standByTrade); 
            console.log("resDelete",res);           
        }   
        else{
            console.log("rifiuto");
            let pendingToUnsolicitedObj = {
                status: "unsolicited",
                receiver: null,
            }
            fetch("http://localhost:3000/trades/pendingToUnsolicited/"+idTrade+"?api_key="+api_key,setPostOption(pendingToUnsolicitedObj))
            .then(response => {
                return response.json();
            })
            .then(response =>{
                console.log("pending",response);
            })
            let standbyToUnsolicitedObj = {
                status: "unsolicited"
            }
            fetch("http://localhost:3000/trades/standByToUnsolicited/"+standBy._id+"?api_key="+api_key,setPostOption(standbyToUnsolicitedObj))
            .then(response => {
                return response.json();
            })
            .then(response =>{
                console.log("standBy",response);
            })
        }
        await trades(idUser); //trova e fa vedere a schermo le carte che non sono state proposte in nei vari scambi
        await manageTrade(idUser); //gestisce e fa vedere a schermo tutta la parte degli scambi che hanno stato, unsolicited, pending e standBy;
        await managePendings(idUser); 
    }

    async function deleteTrades(idTradePending,idTradeStandBy){ //cancella i trade in caso un trade venga accetato
            let flag = false;
            await fetch("http://localhost:3000/trades/"+idTradePending+"?api_key="+api_key,del)
            .then(response => {
                if(response.status == 200)
                    flag = true;
                return response.json();
            })
            console.log("flag delete",flag);
            if(flag){
                await fetch("http://localhost:3000/trades/"+idTradeStandBy+"?api_key="+api_key,del)
                .then(response => {
                    if(response.status == 200){
                        flag = true;
                    }
                    else{
                        flag = false;
                    }
                    return response.json();
                })
                .then(response =>{
                    console.log(response);
                })
            }
            return flag;
    }
    
    async function makeTheEffectiveTrade(idUser,cardsToAdd,cardsToRemove) {
        // console.log("idUser",idUser);
        // console.log("cards to add",cardsToAdd);
        // console.log("cards to remove",cardsToRemove);
        obj = {
            cardsToAdd: cardsToAdd,
            cardsToRemove: cardsToRemove
        }
        let flag = false;
        return fetch("http://localhost:3000/trade/tradeCards/"+idUser+"?api_key="+api_key,setPostOption(obj))
        .then(response => {
            if(response.status == 200){
                flag = true;
            }
            return response.json();
        })
        .then(response =>{
            console.log(response);
            return flag;
        })
    }
</script>
</html>